#	学习笔记

#	2019.08.07
##
###	 [《包学会之深入浅出Vue.js》](https://cloud.tencent.com/developer/column/1930?fromSource=waitui)
##
*	quiButton.vue  	this.$emit	
	*	vm.$emit( eventName, […args] )
		* 参数：
			* {string} eventName
			* [...args]
			* 触发当前实例上的事件。附加参数都会传给监听器回调。
*	 这种做法叫做监听，由引用方（暂且叫做父组件）监听子组件的内置方法；同时在子组件中，需要触发这个事件。
*	 关键代码就是$emit，也叫触发机制，父组件监听，子组件触发。如果觉得绕，以下描述可能会比较好理解：小B（子组件）有一个电话号码（子组件注册的事件），有一天小B把电话号码告诉了小A（父组件），让小A打电话给他，于是小A就拨打了小B的电话号码（监听），这时候整个沟通流程没有结束，必须要小B接听了电话（触发），两人之间才算完成了打电话这件事情。
##

###	Vue.js官方教程学习
##	
###	基础
*	`Object.freeze()`
	*	此代码会阻止修改现有的属性，也意味着响应系统无法再追踪变化。

####	模板语法
*	`v-once`
	*	执行一次性插值，当数据改变时，插值处的内容不会更新。

####	计算属性和侦听器
*	`computed` 和 `methods`
	*	computed是响应式的，methods并非响应式。
	*	调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。
	*	computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。
	*	computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的。
	*	computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果。
*	`v-bind:style`
	*	[对象语法](https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1)十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名。
	*	[数组语法](https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1)可以将多个样式对象应用到同一个元素上。
	*	多重值：
		*	为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值。

####	条件渲染
*	`v-if`和`v-show`
	*	v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件快内的事件监听器和子组件适当地被销毁和重建。
	*	v-if 也是有惰性的：如果在初始渲染时条件为假，则什么也不做--直到条件第一次变为真时，才会开始渲染条件块。
	*	相比之下，v-show 不管初始条件是什么，元素总是会被渲染，并且知识简单的基于CSS进行切换。
	*	**使用建议**：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
*	**不推荐**同时使用v-if和v-for。因为v-for具有比v-if更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。


#	2019.08.08


####	列表渲染
*	数组的更新检测。
	*	变异方法（会改变调用了这些方法的原始数组）
		*	`push()`	往数组最后面添加一个元素，成功返回当前数组的长度
		*	`pop()`	删除数组的最后一个元素，成功返回删除元素的值
		*	`shift()`	删除数组的第一个元素，成功返回删除元素的值
		*	`unshift()`	往数组最前面添加一个元素，成功返回当前数组的长度
		*	`splice()`	有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除后想要在原位置替换的值（可选）
		*	`sort()`	使数组按照字符编码默认从小到大排序,成功返回排序后的数组
		*	`reverse()`	将数组倒序，成功返回倒序后的数组
	*	替换数组（不会改变原始数组，而总是**返回一个新数组**）
		*	`filter()`	过滤
		*	`concat()`	合并数组
		*	`slice()`	在原数组基础上创建一个副本数组，slice()接受一个或两个参数，即要返回项的起始和结束位置。
*	**当在组件上使用 v-for 时，key 现在是必须的**。

####	事件处理

####	表单输入绑定
*	`v-model` 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将Vue 实例的数据作为数据来源。应该通过JavaScript在组件的data选项中声明初始值。

####	组件基础
*	因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、 watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。
*	组件复用，相互独立，因为没用一次组件，就会有一个它的新**实例**被创建。
*	**一个组件的 data 选项必须是一个函数。**

###	深入了解组件 
*	所有的Vue组件同时也都是Vue的实例。可以接受相同的选项对象（除了一些根级特有的选项），并提供相同的生命周期钩子。
*	在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。


*	组件名：
	*	当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，推荐字母全小写且必须包含一个连字符。
	*	除此之外，还可以使用PascalCase（首字母大写命名）定义一个组件。
*	局部注册：
	*	`var ComponentA = { /* ... */ }`
		`var ComponentB = { /* ... */ }`
		![](https://i.imgur.com/gF8TtuB.jpg)
	*	注意：局部注册的组件在其子组件中不可用。
*	Prop 单向数据流
	*	所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新都会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。


**存在较多问题，未看懂**

###	过渡&动画
*	过渡的类名
	*	在进入/离开的过渡中，会有 6 个 class 切换。
		*	v-enter：定义进入过渡的开始状态。
		*	v-enter-active：进入过渡生效时的状态。
		*	v-enter-to：进入过渡的结束状态。
		*	v-leave：离开过渡的开始状态。
		*	v-leave-active：离开过渡生效时的状态。
		*	v-leave-to：离开过渡的结束状态。
	![](https://i.imgur.com/S05FIq5.png)


#	2019.08.09

###	可复用性&组合
*	混入（mixin）提供了一种非常灵活的方式，来分发Vue组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
####	选项合并
*	当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部回进行递归合并，并在发生冲突时**以组件数据优先**。
*	同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用，与放置顺序无关。
*	值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，**取组件对象的键值对**。
*	Vue.extend() 也使用同样的策略进行合并。

####	全局混入
*	混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。
*	**请谨慎使用全局混入**，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。

####	钩子函数
*	一个指令定义对象可以提供如下几个钩子函数 (均为可选)：
	*	bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
	*	inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
	*	update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
	*	componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
	*	unbind：只调用一次，指令与元素解绑时调用。

####	钩子函数参数
*	el：指令所绑定的元素，可以用来直接操作 DOM 。
binding：一个对象，包含以下属性：
*	name：指令名，不包括 v- 前缀。
	*	value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
	*	oldValue：指令绑定的前一个值，仅在 update 和componentUpdated 钩子中可用。无论值是否改变都可用。
	*	expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
	*	arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
	*	modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
*	vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
*	oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

*	**注意：****除了 el 之外**，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。

####	节点、树以及虚拟DOM
*	每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。

####	插件
*	插件通常用来未Vue添加全局功能。插件的功能没有严格的限制------一般有下面几种：
	1. 添加全局方法或者属性。如：vue-custom-element
	2. 添加全局资源：指令/过滤器/过渡等。如：vue-touch
	3. 通过全局混入来添加一些组件选项。如：vue-router
	4. 添加Vue实例方法，通过把它们添加到Vue.protptype 上实现。
	5. 一个库，提供自己的API，同时提供上面提到的一个或多个功能。如：vue-router

#####	使用插件
*	通过全局方法 `Vue.use(MyPlugin)`使用插件。
*	也可传入一个可选的选项对象：
	*	`Vue.use(MyPlougin,{someOption:true})`

#####	开发插件


#	2019.08.10



#	2019.08.12

##
###	Vue CLI
##
