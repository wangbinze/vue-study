#	学习笔记

#	2018.08.07
##
###	 [《包学会之深入浅出Vue.js》](https://cloud.tencent.com/developer/column/1930?fromSource=waitui)
##
*	quiButton.vue  	this.$emit	
	*	vm.$emit( eventName, […args] )
		* 参数：
			* {string} eventName
			* [...args]
			* 触发当前实例上的事件。附加参数都会传给监听器回调。
*	 这种做法叫做监听，由引用方（暂且叫做父组件）监听子组件的内置方法；同时在子组件中，需要触发这个事件。
*	 关键代码就是$emit，也叫触发机制，父组件监听，子组件触发。如果觉得绕，以下描述可能会比较好理解：小B（子组件）有一个电话号码（子组件注册的事件），有一天小B把电话号码告诉了小A（父组件），让小A打电话给他，于是小A就拨打了小B的电话号码（监听），这时候整个沟通流程没有结束，必须要小B接听了电话（触发），两人之间才算完成了打电话这件事情。
##

###	Vue.js官方教程学习
##	
###	基础
*	`Object.freeze()`
	*	此代码会阻止修改现有的属性，也意味着响应系统无法再追踪变化。

####	模板语法
*	`v-once`
	*	执行一次性插值，当数据改变时，插值处的内容不会更新。

####	计算属性和侦听器
*	`computed` 和 `methods`
	*	computed是响应式的，methods并非响应式。
	*	调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。
	*	computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。
	*	computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的。
	*	computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果。
*	`v-bind:style`
	*	[对象语法](https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1)十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名。
	*	[数组语法](https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1)可以将多个样式对象应用到同一个元素上。
	*	多重值：
		*	为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值。

####	条件渲染
*	`v-if`和`v-show`
	*	v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件快内的事件监听器和子组件适当地被销毁和重建。
	*	v-if 也是有惰性的：如果在初始渲染时条件为假，则什么也不做--直到条件第一次变为真时，才会开始渲染条件块。
	*	相比之下，v-show 不管初始条件是什么，元素总是会被渲染，并且知识简单的基于CSS进行切换。
	*	**使用建议**：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
*	**不推荐**同时使用v-if和v-for。因为v-for具有比v-if更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。


#	2018.08.08


####	列表渲染
*	数组的更新检测。
	*	变异方法（会改变调用了这些方法的原始数组）
		*	`push()`	往数组最后面添加一个元素，成功返回当前数组的长度
		*	`pop()`	删除数组的最后一个元素，成功返回删除元素的值
		*	`shift()`	删除数组的第一个元素，成功返回删除元素的值
		*	`unshift()`	往数组最前面添加一个元素，成功返回当前数组的长度
		*	`splice()`	有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除后想要在原位置替换的值（可选）
		*	`sort()`	使数组按照字符编码默认从小到大排序,成功返回排序后的数组
		*	`reverse()`	将数组倒序，成功返回倒序后的数组
	*	替换数组（不会改变原始数组，而总是**返回一个新数组**）
		*	`filter()`	过滤
		*	`concat()`	合并数组
		*	`slice()`	在原数组基础上创建一个副本数组，slice()接受一个或两个参数，即要返回项的起始和结束位置。
*	**当在组件上使用 v-for 时，key 现在是必须的**。

####	事件处理

####	表单输入绑定
*	`v-model` 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将Vue 实例的数据作为数据来源。应该通过JavaScript在组件的data选项中声明初始值。

####	组件基础
*	因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、 watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。
*	组件复用，相互独立，因为没用一次组件，就会有一个它的新**实例**被创建。
*	**一个组件的 data 选项必须是一个函数。**

###	深入了解组件 
*	组件名：
	*	当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，推荐字母全小写且必须包含一个连字符。
	*	除此之外，还可以使用PascalCase（首字母大写命名）定义一个组件。
*	局部注册：
	*	`var ComponentA = { /* ... */ }`
		`var ComponentB = { /* ... */ }`
		![](https://i.imgur.com/gF8TtuB.jpg)
	*	注意：局部注册的组件在其子组件中不可用。
*	Prop 单向数据流
	*	所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新都会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。


**存在较多问题，未看懂**

###	过渡&动画
*	过渡的类名
	*	在进入/离开的过渡中，会有 6 个 class 切换。
		*	v-enter：定义进入过渡的开始状态。
		*	v-enter-active：进入过渡生效时的状态。
		*	v-enter-to：进入过渡的结束状态。
		*	v-leave：离开过渡的开始状态。
		*	v-leave-active：离开过渡生效时的状态。
		*	v-leave-to：离开过渡的结束状态。
	![](https://i.imgur.com/S05FIq5.png)