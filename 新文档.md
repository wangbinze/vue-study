

## 	组件基础
* 因为**组件是可复用的 Vue 实例**，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。
* 可以将组件**进行任意次数的复用**。
* 一个组件的 **data 选项必须是一个函数**。

###		组件的组织
* 两种组件的注册类型：全局注册和局部注册。
	* Vue.component	---全局注册
		* `Vue.component('my-component-name', {
		  		// ... options ...
		    })`
		* 全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
	* ---全局注册

###		通过Prop向子组件传递数据
* Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。

##	深入了解组件
###		组件注册
* 组件名
	* 你给与组件的名字可能依赖于你打算拿它来做什么。当直接在DOM中使用一个组件（而不是在字符串模板或单文件组件）的时候，我们强烈推荐遵循 [W3C](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name) 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。
	* 组件名大小写（定义组件名的方式有两种）
		* 使用kebab-case（短横线分隔命名）
			* `Vue.component('my-component-name', { /* ... */ })`
			* 当使用kebab-case定义一个组件时，也必须在引用这个自定义元素时使用kebab-case，例如：<my-component-name>。
		* 使用PascalCase（驼峰命名法）
			* `Vue.component('MyComponentName', { /* ... */ })`
			* 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。

* 全局注册

* 局部注册
	* 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。
		* 可以通过一个普通的 JavaScript 对象来定义组件：
		 * `var ComponentA = { /* ... */ }`
		 * `var ComponentB = { /* ... */ }`
		 * `var ComponentC = { /* ... */ }`
		* 然后在 components 选项中定义你想要使用的组件：
		 * `new Vue({
			  el: '#app',
			  components: {
			    'component-a': ComponentA,
			    'component-b': ComponentB
			  }
			})`
		* 对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象
	* 注意局部注册的组件在其子组件中不可用。

###		Prop
* Prop的大小写 (camelCase vs kebab-case)
	* HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：
		* `Vue.component('blog-post', {
			  // 在 JavaScript 中是 camelCase 的
			  props: ['postTitle'],
			  template: '<h3>{{ postTitle }}</h3>'
			})`
		* `<!-- 在 HTML 中是 kebab-case 的 -->
			<blog-post post-title="hello!"></blog-post>`
		* 当然，如果使用字符串模板，那么这个限制就不存在了。

* [Prop类型](https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B)
	
* 单向数据流
	* 所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的引用的数据流向难以理解。
	* 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

* 非Prop的特效
	* 禁用特性继承
		* 如果**不**希望组件的根元素继承特效，可以在组件的选项中设置inheritAttrs: false。
			* `Vue.component('my-component', {
				  inheritAttrs: false,
				  // ...
				})`

##	自定义事件
###		事件名
* 不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要匹配监听这个事件所用的名称。